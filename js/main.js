
//МАССИВ
const questions = [
//     {
//         question: "Что такое LA? В каких единицах измеряется?",
//         answers: ["LA (load average) — параметр, определяющий среднюю нагрузку на систему за период времени (1 мин, 5 минут, 15 минут). Измеряется в количестве задач на одно ядро процессора",
//         "LA — Los Angeles, город в США. Единицы измерения подразумевают площадь города",
//         "LA – употребляется перед существительными женского рода единственного числа (la carrete – катушка, la hija – дочь, la estepa – степь)."
//     ],
//         correct: 1,
//         guide: `Средние значения нагрузки в Linux — это «средние значения нагрузки системы», показывающие потребность в исполняемых потоках (задачах) в виде усреднённого количества исполняемых и ожидающих потоков. Это мера нагрузки, которая может превышать обрабатываемую системой в данный момент. Большинство инструментов показывает три средних значения: для 1, 5 и 15 минут 
//         Некоторые интерпретации:

//         Если значения равны 0.0, то система в состоянии простоя.
//         Если среднее значение для 1 минуты выше, чем для 5 или 15, то нагрузка растёт.
//         Если среднее значение для 1 минуты ниже, чем для 5 или 15, то нагрузка снижается.
//         Если значения нагрузки выше, чем количество процессоров, то у вас могут быть проблемы с производительностью (в зависимости от ситуации).
//         `,
//     },
//     {
//         question: "Что будет если на сервере LA = 100?",
//         answers: ["Ничего не изменится",
//         "Сервер вовсе перестанет отвечать на запросы пользователя",
//         "Вероятно, что на сервере будет наблюдаться замедленная работа сервисов"
//     ],
//         correct: 3,
//         guide:"Если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной. Но в остальных случаях может наблюдаться замедленная работа сервисов",
//     },
//     {
//         question: "Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?",
//         answers: ["На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр wa в утилите top) в дисков и задержка сети",
//         "Сервер оснащён мощным программным обеспечением, которое помогает справиться с высокой нагрузкой",
//         "Оба ответа правильные"
//     ],
//         correct: 1,
//         guide:"Ожидание ввода-вывода и задержка сети могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему",
//     },
//     {
//         question: `Представлен вывод команды top. Что означает каждая запись в выводе?
//         top - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10
//         Tasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie
//         %Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st
//         KiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache
//         KiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem`,
//         answers: [`top – название утилиты.

//         21:29:24 – текущее время системы.
        
//         up 14:18 – сколько часов:минут система работает с момента последнего запуска.
        
//         1 user – количество пользователей авторизованных в системе.
        
//         load average: 0,78, 1,48, 1,10 – параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.
        
//         277 total – всего процессов в системе.
//         `,
//     `3 running – количество процессов в работе.

//     274 sleeping – количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала.
    
//     0 stopped – количество приостановленных процессов сигналом STOP или выполнением трассировки.
    
//     0 zombie – количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.
//     `,
//     `KiB Mem – количество оперативной памяти в кибибайтах (кратно 1024): 7106404 total — всего доступно оперативной памяти в системе, 306972 free — свободно оперативной памяти для использования, 3127144 used — использовано оперативной памяти, 3672288 buff/cache — буферизовано/закешировано оперативной памяти.

//     KiB Swap – количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске: 8191996 total – всего выделено swap-памяти, 8191996 free – свободно swap-памяти 0 used – использовано swap-памяти, 3270520 avail Mem – доступно для использования swap-памяти.
//     `,
//     "Всё вместе"
//     ],
//     correct: 4,
//     guide:"Top - команда, которая позволяет пользователям отслеживать процессы и использование системных ресурсов в Linux",
//     },
//     {
//         question: "Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?",
//         answers: ["В утилите top нажать 1, чтобы отобразить все ядра в системе",
//         "Прописать команду в терминале: top la",
//         "Это невозможно сделать"
//     ],
//         correct: 1,
//         guide:`
//         Для работы с утилитой top также используются следующие клавиши: <br>

// Пробел — обновить вывод <br>

// M — сортировка по используемой памяти <br>

// P — сортировка по нагрузке на процессор (используется по умолчанию)<br>

// T — сортировка по времени работы процесса<br>

// A — сортировка по максимальному потреблению различных ресурсов<br>

// u — сортировка по имени пользователя (потребуется ввести имя пользователя)<br>

// k — завершить процесс (потребуется указать его идентификатор, PID)<br>

// n — изменить количество процессов в выводе (потребуется указать нужное количество)<br>

// c — вывести полный путь запущенного процесса (столбец COMMAND)<br>

// h — вывод справки<br>

// q — выход из программы
//         `,
//     },
//     {
//         question: "Как в утилите top в Linux посмотреть какой командой был запущен процесс?",
//         answers: ["Прописать команду в терминале: top commands",
//         "В утилите top нажать c, чтобы отобразить команды, которыми были запущены процессы",
//         "Это невозможно сделать"
//     ],
//         correct: 2,
//         guide:`
//         Для работы с утилитой top также используются следующие клавиши: <br>

// Пробел — обновить вывод <br>

// M — сортировка по используемой памяти <br>

// P — сортировка по нагрузке на процессор (используется по умолчанию)<br>

// T — сортировка по времени работы процесса<br>

// A — сортировка по максимальному потреблению различных ресурсов<br>

// u — сортировка по имени пользователя (потребуется ввести имя пользователя)<br>

// k — завершить процесс (потребуется указать его идентификатор, PID)<br>

// n — изменить количество процессов в выводе (потребуется указать нужное количество)<br>

// c — вывести полный путь запущенного процесса (столбец COMMAND)<br>

// h — вывод справки<br>

// q — выход из программы
//         `,
//     },
//     {
//         question: "Где хранятся имена файлов/директорий?",
//         answers: ["Команда files, которая хранит и возвращает имена файлов/директорий",
//         "В базе данных на отдельном локальном сервере",
//         "Имя файла/директории хранится в информационной структуре каталогов"
//     ],
//         correct: 3,
//         guide: `Inodes не содержат имён файлов, только другие метаданные файла.<br>
//         Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.<br>
//         Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.<br>
//         <i>Таким образом имя файла/директории хранится в информационной структуре каталогов.</i>`,
//     },
//     {
//         question: "Как удалить файл с именем -rf?",
//         answers: ["rm -rf",
//         "rm -f ./-rf",
//         "rm -f ./rf"
//     ],
//         correct: 2,
//         guide: `
//         Удалить файл, начинающийся с дефиса простым экранированием не получится, и команда rm будет воспринимать дефис, как начало своего аргумента. Решить проблему довольно просто:<br>

//         <i>$ rm -f ./-abc</i><br>

//         или:<br>

//         <i>$ rm -f -- -abc</i>
//         `,
//     },
//     {
//         question: "Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?",
//         answers: ["stat 'path_to_file' и stat --format=%y 'path_to_file'",
//         "descr 'path_to_file' и descr --format=%y dira",
//         "Никак ;("
//     ],
//         correct: 1,
//         guide: `
//         Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. <br>
        
//         Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.<br>
//         Команда stat даёт полную информацию о файле и его дескрипторе. Флаг <i>--format=%y</i> позволяет посмотреть время последней модификации файла
//         `,
//     },
//     {
//         question: "Для чего нужна переменная окружения PATH?",
//         answers: ["Хранит в себе локальные пути к исполняемым файлам",
//         "Переменная окружения PATH содержит абсолютные пути директорий, в которых производится поиск исполняемых файлов при вводе команд",
//         "Оба варианта верные"
//     ],
//         correct: 2,
//         guide: "Переменная PATH — это системная переменная, которую операционная система использует для того, чтобы найти нужные исполняемые объекты в командной строке или окне терминала",
//     },
//     {
//         question: "Как посмотреть нагрузку на диски?",
//         answers: ["Установить утилиту sysstat, проверить нагрузку на диски iostat -xqc",
//         "Установить утилиту sysstat, проверить нагрузку на диски iostat -xtc",
//         "Установить утилиту suuus, проверить нагрузку на диски impostats -sus"
//     ],
//         correct: 2,
//         guide: "Утилита iostat является частью пакета sysstat. Аргумент -xtc помогает проверить нагрузку на диски",
//     },
//     {
//         question: "Что такое файл в понятиях Unix-like операцинных системах?",
//         answers: ["Файлы – это все, что хранит информацию и данные",
//         "Файл – прозрачный перфорированный пакет для документов носит несколько названий «файлик», «мультифора» и «карман»",
//         "Файл – именованная область данных на носителе информации, используемая как базовый объект взаимодействия с данными в операционных системах"
//     ],
//         correct: 1,
//         guide: `Unix-like ОС - операционная система, которая образовалась под влиянием Unix. <br>
//         Философия операционных систем Unix гласит, что все есть файл. Это значит, что вся работа с этой операционной системой сводится к файлам
//         `,
//     },
//     {
//         question: "Что такое RAID? Какие массивы бывают?",
//         answers: ["RAID - это способ хранения данных, который не обеспечивает защиту информации. Массивы RAID бывают только одного уровня, который не влияет на производительность хранения данных.",
//         "RAID (Redundant Array of Independent Disks) – избыточный массив независимых дисков, технология виртуализации данных для повышения отказоустойчивости и производительности. Существуют следующие основные типы RAID: RAID 0: RAID 1: RAID 5: RAID 6: RAID 10"
//     ],
//         correct: 2,
//         guide: `
//         RAID — это технология, с помощью которой может быть организовано хранение данных на жёстких дисках. По-простому — это инструкция, как хранить и читать ваши файлы на дисках. <br>
//         Суть безопасности RAID в том, чтобы при поломке одного из дисков данные в целом не пострадали. По крайней мере, чтобы их можно было восстановить. <br>
//         Основные виды RAID-массивов:<br>
//         -RAID0 - большая скорость обработки, небезопасность хранения<br>
//         -RAID1 - высокая безопасность(два диска дублирующие друг друга)<br>
//         -RAID5 - много места, высокая надёжность(третий диск с доп инфой)<br>
//         -RAID10 - микс RAID0 и RAID1(требует много дисков)
//         `,

//     },
//     {
//         question: "При каком количестве одновременно вышедших из строя дисков обеспечивает работоспособность RAID 6?",
//         answers: ["3 диска",
//         "1 диск",
//         "2 диска",
//     ],
//         correct: 3,
//         guide: `
//         RAID6 - массив из четырёх или более дисков с проверкой чётности, разработанный для защиты от потери данных при выходе из строя сразу двух жестких дисков в массиве
//         `,

//     },
//     {
//         question: `В чем разница между объявлением переменной export VAR="VALUE" и VAR="VALUE" в bash?`,
//         answers: ["В первом случае мы обозначаем глобальную переменную(переменную окружения), а во втором локальную(переменную оболочки)",
//         "В первом случае мы обозначаем локальную переменную(переменную окружения), а во втором глобальную(переменную оболочки)",
//         "В первом случае мы обозначаем глобальную переменную(переменную оболочки), а во втором локальную(переменную окружения)",
//     ],
//         correct: 1,
//         guide: `
//         Переменная окружения(1) в bash имеет тот же функционал, что и глобальные переменные в других языках, а переменная оболочки(2) эквивалентна локальным переменным.
//         `,

//     },
//     {
//         question: "Как остановить выполнение скрипта в bash при возникновении ошибки в команде?",
//         answers: ["error -s",
//         "set -e",
//         "stop -e",
//     ],
//         correct: 2,
//         guide: `
//         Команда set -e завершит скрипт с ошибкой, в случае, если в нижеследующем bash коде будет обнаружена ошибка. По-умолчанию bash скрипт продолжает работу, если в ходе выполнения возникла ошибка.
//         `,

//     },
//     {
//         question: "Что в bash скрипте означает команда <i>set -euo pipefail?</i>",
//         answers: ["Cкрипт будет остановлен, когда произойдет ошибка в ходе его выполнения",
//         "Cкрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена",
//         "Cкрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка",
//         "Объединение всех вариантов"
//     ],
//         correct: 4,
//         guide: `
//         Команда set устанавливает аттрибуты оболочки с опеределенных опций. Опция -e – означает, что скрипт будет остановлен, когда произойдет ошибка в ходе его выполнения. Опция -u – означает, что скрипт будет остановлен, если в ходе скрипта, будет обнаружена переменная, которая не определена. Опция -o pipefail – означает, что скрипт будет остановлен, если в ходе пайплайна команд будет выявлена ошибка.<br>
//         pipeline - последовательность из одной или нескольких команд, разделенных одним из управляющих операторов "|" или "|&".
//         `,

//     },
//     {
//         question: "Как активировать debug режим в bash?",
//         answers: ["start debug",
//         "set --debug",
//         "set -x",
//     ],
//         correct: 3,
//         guide: `
//         Команда set -x в начале скрипта активирует вывод в консоль debug информации.
//         `,

//     },
//     {
//         question: "Что значит $@ в bash?",
//         answers: ["Это шебанг",
//         "Все параметры переданные скрипту",
//         "Конец скрипта",
//     ],
//         correct: 2,
//         guide: `
//         $@ это ВСЕ параметры, переданные скрипту<br>

//         Например, если вы вызовете <i>./someScript.sh foo bar</i> , то <i>$@ будет равно foo bar</i>
//         `,

//     },
//     {
//         question: "Какой код сигнала будет выполнен при исполнении команды kill <PID>",
//         answers: ["Сигнал SIGTERM (код 15) – это сигнал по-умолчанию отправляемый при вызове команды kill",
//         "Сигнал SIGINT (код 2) – сигнал о прерывании процесса с клавиатуры (обычно при нажатии комбинации клавиш Ctrl+C)",
//         "SIGKILL(код 9) - сигнал используется для немедленного завершения программы (не может быть обработан, проигнорирован или заблокирован)"
//     ],
//         correct: 1,
//         guide: `
//         По умолчанию команда kill посылает сигнал SIGTERM запущенному процессу(чистое завершение работы). Это действие обычно останавливает работающие процессы. Если Вы хотите остановить процесс — просто укажите его идентификатор PID в переменной ProcessID
//         `,

//     },
//     {
//         question: "Как выполнить фильтрацию вывода команды, чтобы на экран были выведены только ошибки (STDERR), игнорируя STDOUT?",
//         answers: ["cmd 2>&1 >/dev/null | grep pattern",
//         "cmd 1>&2 >/dev/null",
//         "cmd 2>&3 >/dev/grep | grep pattern",
//     ],
//         correct: 1,
//         guide: `
//         Для потоков stdout и stderr тоже определены файловые дескрипторы, причем с фисксированными номерами: 1 для sdtout и 2 для stderr.<br>
//         Запись &1 означает значение файлового дескриптора 1 (stdout). Поэтому выражение 2>&1 означает, что stderr (2) перенаправляется в то же место, куда был перенаправлен stdout (1):
//         `,

//     },
//     {
//         question: "Какую команду необходимо выполнить, чтобы посмотреть какие пользователи вошли в систему в систему?",
//         answers: ["Ввести users --online онлайн",
//         "Ввести users в терминале",
//         "Ввести w в терминале",
//     ],
//         correct: 3,
//         guide: `
//         Команда w покажет список пользователей, которые вошли на сервер.
//         `,

//     },
//     {
//         question: "Какой файл необходимо отредактировать, чтобы отключить ssh аутентификацию по паролю?",
//         answers: ["файл /etc/ssh/ssh",
//         "файл /etc/ssh/ss_config",
//         "файл /etc/ssh/sshd_config",
//     ],
//         correct: 3,
//         guide: `
//         Файл по пути /etc/ssh/sshd_config отвечает за конфигурацию сервиса ssh
//         `,

//     },
//     {
//         question: "В каком файле находится информация о смонтированных каталогах в файловую систсему?",
//         answers: ["/etc/catalogs",
//         "/etc/fstab",
//         "/etc/fs",
//     ],
//         correct: 2,
//         guide: `
//         Операционные системы семейства Linux имеют одну замечательную особенность. Здесь все разделы отображаются не в каком-либо абстрактном месте под названием "Мой компьютер", а монтируются в корневую файловую систему. Вы можете управлять тем, куда и как будет смотирован определённый раздел. В корневую файловую систему монтируются все разделы ваших жёстких дисков, флешки, сетевые папки и виртуальные файловые системы.<br>

//         В результате всего этого вы получаете единую и цельную файловую систему, с помощью которой можно управлять всеми возможностями Linux. Монтировать можно не только разделы, но и папки. <br>
//         Файл /etc/fstab содержит информацию о смонтированных каталогах в файловую систему.
//         `,

//     },
//     {
//         question: `Что выведет команда cat a и почему?<br>
//        <i> mkdir /tmp/abc<br>
//         cd /tmp/abc<br>
//         ls >a 2>b <br>
//         cat a </i>`,
//         answers: [`cat a выведет<br>
//         <i>a<br>
//         b</i>`,
//         `cat a выведет<br>
//         <i>b<br>
//         a</i>`,
//         `cat a выведет<br>
//         <i>a<br>
//         a</i>`,
//     ],
//         correct: 1,
//         guide: `
//         Обработка команды идёт справа налево. Сначала создается файл b, потом создается файл a, команда ls отображает список файлов в текущей директории (файлы a и b уже созданы) в одну колонну и перенаправляет стандартный поток вывода (>) в файл a, а стандартный поток ошибок 2 в файл b
//         `,

//     },
//     {
//         question: "В bash-скрипте указан аттрибут оболочки set -x. В одной из команд происходит ошибка и скрипт завершает свою работу. Как сделать, чтобы при возникновении ошибки в определенной команде скрипт продолжил свою работу?",
//         answers: [
//             "<command with error> || false",
//             "<command with error> || true",
//             "<command with error> && true"
//         ],
//         correct: 2,
//         guide: `
//         2 вариант: до выполнения данной команды указать set +e для игнорирования ошибок, начиная со следующей строки и после выполнения команды указать set -e для завершения работы скрипта в случае ошибки, начиная со следующей строки.<br>
//         <i>set -e<br>
//         <command 1><br>
//         <command 2><br>
//         set +e<br>
//         <command 3 wih error><br>
//         set -e</i>
//         `,
//     },
//     {
//         question: "Что такое системный вызов?",
//         answers: [
//             "Обращение программы к ядру операционной системы для выполнения какой-либо операции",
//             "Обращение программы к корневому каталогу для выполнения какой-либо операции",
//         ],
//         correct: 1,
//         guide: `
//         Системный вызов – обращение программы к ядру операционной системы для выполнения какой-либо операции.

//         В Unix, Unix-like и других POSIX-совместимых операционных системах популярными системными вызовами являются:<br>
//         <i>
//         open<br>
//         read<br>
//         write<br>
//         close<br>
//         wait<br>
//         exec<br>
//         fork<br>
//         exit<br>
//         kill</i>
//         `,
//     },
//     {
//         question: "Что такое сигнал в Unix, зачем они нужны?",
//         answers: [
//             "Сигнал – в Unix-like операционных системах – асинхронное (в случайное время) уведомление процесса для обработки какого-либо события. Один из основных способов взаимодействия между процессами",
//             "Сигна́л (от лат. signum — знак) — изменение физической величины, несущее информацию",
//             "Сигна́л — материальное воплощение сообщения для использования при передаче, переработке и хранении информации"
//         ],
//         correct: 1,
//         guide: `
//         Посылка сигналов от одного процесса к другому обычно осуществляется при помощи системного вызова kill. Его первый параметр – PID процесса, которому посылается сигнал; второй параметр – номер сигнала<br>
//         <i>kill(1111, SIGTERM)</i><br>
//         SIGTERM	15	Сигнал завершения (сигнал по умолчанию для утилиты kill)<br>
//         SIGKILL	9	Безусловное завершение
//         `,
//     },
//     {
//         question: "Что такое inode? Какая информация там хранится?",
//         answers: [
//             "Inode – совокупность множества однородных предметов, составляющих единое целое",
//             "Inode (индексный дескриптор) – структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных"
//         ],
//         correct: 2,
//         guide: `
//         Inode (индексный дескриптор) – структура данных, в которой хранятся метаданные файла и перечислены блоки с данными файла. Хранит всю информацию, кроме имени файла и данных. Каждый файл в данном каталоге является записью с именем файла и номером индекса. Вся остальная информация о файле извлекается из таблицы индексов путем ссылки на номер индекса. Номера inodes уникальны на уровне раздела. Каждый раздел как собственная таблица индексов. Если у вас закончились inode, вы не можете создавать новые файлы, даже если у вас есть свободное место на данном разделе.

//         Inodes хранит метаданные о файле, к которому он относится. Эти метаданные содержат всю информацию об указанном файле.<br>

//         Размер<br>
//         Разрешение<br>
//         Владелец/группа<br>
//         Расположение жесткого диска<br>
//         Дата/время<br>
//         Любая другая необходимая информация
//         `,
//     },
//     {
//         question: "Что такое hard link? В чем разница между hard link и soft link?",
//         answers: [
//             "soft links содержат адрес нужного файла в вашей файловой системе, hard links - это отдельные файлы, но ведут они к одному участку жесткого диска",
//             "отличия незначительны",
//             "soft links - это отдельные файлы, но ведут они к одному участку жесткого диска, hard links содержат адрес нужного файла в вашей файловой системе"
//         ],
//         correct: 1,
//         guide: `
//             realFile(<i>touch realFile</i>) и hardLink(<i>ln realFile hardLink</i>) имеют одинаковый идентификатор inode<br>
//             Чистовой идентификатор softLink(<i>ln -s realFile softLink</i>) отличается от числового идентификатора realFile
//         `,
//     },
//     {
//         question: "Какие состояния процессов существуют? Что значит состояние процесса D?",
//         answers: [
//             "R, D, S, T, Z, W, <, N, L, s. D - ожидает записи на диск",
//             "Z, X, C , W, D. D - ожидает записи на диск",
//             ">, <, B, A, O, K , P. D - ожидает записи на диск"
//         ],
//         correct: 1, 
//         guide: `
//         R (running or runnable)	Выполняется или готов к выполнению<br>
//         D (uninterruptible sleep)	Ожидает записи на диск<br>
//         S (interruptible sleep)	Неактивен (< 20 s)<br>
//         T (stopped by job control signal)	Остановлен или трассируется отладчиком<br>
//         Z (zombie)	зомби<br>
//         W (paging (not valid since the 2.6.xx kernel))	Процесс выгружен на диск<br>
//         <	Процесс имеет повышенный приоритет nice<br>
//         N	Процесс имеет пониженный приоритет nice<br>
//         L (locked)	Некоторые страницы блокированы в ядре<br>
//         s	Процесс является лидеров сеанса
//         `,
//     },
//     {
//         question: "Что такое процесс-зомби и процесс-сирота?",
//         answers: [
//             `Процесс-зомби – дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения<br>
//             Процесс-сирота — в семействе операционных систем UNIX вспомогательный процесс, чей основной процесс (или связь с ним) был завершен нештатно (не подав сигнала на завершение работы)
//             `,
//             "Процесс-зомби - процесс, подавший сигнал на завершение работы, но запущенный заново без команды пользователя. Процесс-сирота - это термин, обозначающий процесс, который остался без должного внимания, контроля или управления",
//             "Процесс-зомби - процесс, восставший из мёртвых. Процесс-сирота - процесс, оставшийся без родителей(Питер Паркер)"
//         ],
//         correct: 1,
//         guide: `
//         Удаление зомби возлагается на родительский процесс или системный вызов wait() также может это выполнить, поэтому перед ее вызовом не нужно проверять, продолжает ли выполняться требуемый дочерний процесс. Если родительский процесс не удалит своих потомков, то они останутся в состоянии зомби.

//         Убить зомби-процесс невозможно. Чтобы убить зомби-процесс нужно найти родительский процесс и завершить его или перезапустить.<br>
//         В отличии от процесса-сироты, зомби-процесс неактивен, но контролируется родительским процессом, пока тот не решит, что статус выхода дочерних процессов больше не нужен. Он не использует ресурсы и не может быть запланирован для выполнения. Иногда родительский процесс удерживает дочерний процесс в состоянии зомби, чтобы гарантировать, что будущие дочерние процессы не получат тот же PID. Если вы уничтожите родителя зомби-процесса, зомби-процесс тоже умрет
//         `,
//     },
//     {
//         question: "Что такое файловый дескриптор?",
//         answers: [
//             "Дескриптор – это короткое описание товара или услуги представленной на сайте",
//             "Файловый дескриптор – неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета",
//             "Дескри́птор (от лат. descriptor «описывающий») — лексическая единица (слово, словосочетание) информационно-поискового языка"
//         ],
//         correct: 2,
//         guide: `
//         Файловый дескриптор – неотрицательное целое число, которое используется в интерфейсе между пространством пользователя и пространством ядра (kernel) для идентификации ресурсов файла / сокета. Когда создаётся новый поток ввода-вывода, ядро возвращает процессу, создавшему поток ввода-вывода, его файловый дескриптор.
//         `,
//     },
//     {
//         question: "Что такое buffer/cache память? Для чего нужна?",
//         answers: [
//             "Это вид памяти, позволяющий операционной системе хранить данные, которые были считаны и переданы на обработку",
//             "Это вид памяти, позволяющий операционной системе временно хранить данные, которые были считаны, но не переданы на обработку",
//         ],
//         correct: 2,
//         guide: `
//         Это временное хранилище, используемое для ускорения доступа к данным или ресурсам. В информационных технологиях и компьютерных системах кэш — это специально выделенный участок памяти, который содержит скопированные или предварительно загруженные данные, которые часто запрашиваются программами или пользователем.
//         `,
//     },
//     {
//         question: "Порядок загрузки дистрибутива Linux",
//         answers: [
//             `Включение компьютера кнопкой.<br>
//             Загрузить BIOS / UEFI из NVRAM.<br>
//             Собрать сведения об аппаратуре.<br>
//             Выбрать устройства для запуска (диск, сеть)`,
//             `Идентифицировать системный раздел EFI.<br>
//             Загрузить BIOS / UEFI из NVRAM.<br>
//             Определить какое ядро загрузить.<br>
//             Загрузить ядро.`,
//             `Создать структуры данных ядра.
//             Запустить init / systemd как PID 1.
//             Выполнить сценарии запуска.
//             Запустить систему.`,
//             "Все варианты верные"
//         ],
//         correct: 4,
//         guide: `
        
//         `,
//     },
//     {
//         question: "Что такое GitFlow?",
//         answers: [
//             "Это устаревшая версия рабочего процесса Git, в свое время ставшая принципиально новой стратегией управления ветками в Git",
//             "Это новейшая версия рабочего процесса Git, ставшая принципиально новой стратегией управления ветками в Git",
//         ],
//         correct: 1,
//         guide: `
//         Популярность Git-flow стала снижаться под влиянием магистральных рабочих процессов, которые на сегодня считаются предпочтительными для современных схем непрерывной разработки ПО и применения DevOps. Кроме того, Git-flow не слишком удобно применять в процессах CI/CD
//         `,
//     },
//     {
//         question: "Чем merge отличается от rebase?",
//         answers: [
//             "это одна и та же функция",
//             "merge повторно применяет коммиты поверх другой базовой ветви, тогда как rebase объединяет две или более истории разработки вместе",
//             "rebase повторно применяет коммиты поверх другой базовой ветви, тогда как merge объединяет две или более истории разработки вместе"
//         ],
//         correct: 3,
//         guide: `
//         Коммит — это пакет изменений, хранящий информацию с добавленными, отредактированными или удалёнными файлами кода<br>
//         Ветка в Git — это набор коммитов, расположенных в хронологическом порядке
//         `,
//     },
//     {
//         question: "Чем tag отличается от branch?",
//         answers: [
//             "tag - ссылки на конкретные версии вашего кода в репозитории Git. branch - это просто «скользящий» указатель на один из коммитов. Когда вы создаёте новые коммиты, указатель ветки автоматически сдвигается вперёд, к вновь созданному коммиту",
//             "branch - ссылки на конкретные версии вашего кода в репозитории Git. tag - это просто «скользящий» указатель на один из коммитов. Когда вы создаёте новые коммиты, указатель ветки автоматически сдвигается вперёд, к вновь созданному коммиту"
//         ],
//         correct: 1,
//         guide: `
//         Коммит — это пакет изменений, хранящий информацию с добавленными, отредактированными или удалёнными файлами кода<br>
//         Ветка в Git — это набор коммитов, расположенных в хронологическом порядке
//         `,
//     },
//     {
//         question: "В ветке develop есть коммит с изменениями, которые нужно перенести в ветку master. Как это сделать?",
//         answers: [
//             "git merge master",
//             "git merge develop"
//         ],
//         correct: 1,
//         guide: `
//         Процедура объединения веток называется слияние (merge).<br>
//         Для слияния текущей ветки с какой-либо другой используется команда<br>
//         git merge имя_ветки
//         `,
//     },
//     {
//         question: "Для чего нужна команда git commit --amend?",
//         answers: [
//             "внесение изменений в последний коммит",
//             "удаление последнего коммита",
//             "создание нового коммита"
//         ],
//         correct: 1,
//         guide: `
//         Команда git commit --amend — это удобный способ изменить последний коммит. Она позволяет объединить проиндексированные изменения с предыдущим коммитом без создания нового коммита
//         `,
//     },
//     {
//         question: "Что такое Trunk-based development?",
//         answers: [
//             "Методология разработки программного обеспечения",
//             "Принцип работы в веб-студиях"
//         ],
//         correct: 1,
//         guide: `
//         Это методология разработки программного обеспечения, которая предлагает использовать только одну основную ветку, trunk, для разработки и интеграции всех изменений в коде. Это означает, что все разработчики работают непосредственно в trunk и делают коммиты прямо в эту ветку.
//         `,
//     },
//     {
//         question: "Состояние репозитория ушло на много коммитов вперед. Как откатить весь репозиторий к определенному коммиту?",
//         answers: [
//             "git reset --soft <old-commit-id>",
//             "git reverse --hard <old-commit-id>",
//             "git reset --hard <old-commit-id>"
//         ],
//         correct: 3,
//         guide: `
//         Флаг --hard сообщает Git, что необходимо сбросить ветвь в указанную фиксацию и отменить все последующие изменения. Будьте осторожны с этим вариантом, так как вы можете потерять работу с ним
//         `,
//     },
//     {
//         question: "В репозиторий запушен коммит с изменениями в двух файлах. Как откатить изменения этого коммита?",
//         answers: [
//             "git reverse HEAD",
//             "git revert HEAD",
//             "git reset --hard HEAD"
//         ],
//         correct: 2,
//         guide: `
//         Для отката изменений коммита в репозитории можно использовать команду git revert для создания нового коммита, который отменяет изменения предыдущего коммита. Например, если нужно откатить последний коммит, можно использовать команду:<br></br>

// <i>git revert HEAD</i>
//         `,
//     },
    {
        question: "Что такое Docker? В чем отличие контейнера от образа?",
        answers: [
            "Docker — это проект для автоматизации развертывания приложений в виде переносимых автономных контейнеров, выполняемых в облаке или локальной среде. Образ – это набор программного обеспечения на диске, а контейнер – работающий экземпляр образа вместе со сведениями о времени и процессах выполнении операции",
            "Docker — аналог системы контроля версий Git. Образ = коммит, а контейнер = ветка",
            "Docker — сервис, позволяющий запустить локальный сервер на вашем компьютере. Образ - база данных сервера, контейнер - UX/UI"
        ],
        correct: 1,
        guide: `
        В статьях о Docker часто встречаются слова на «контейнеры» и «образы». Это не одно и то же, хотя иногда они используются как синонимы. Существует большая разница между этими двумя понятиями: образ – это набор программного обеспечения на диске, а контейнер – работающий экземпляр образа вместе со сведениями о времени и процессах выполнении операции
        `,
    },
    {
        question: "Какая инструкция Dockerfile устанавливает переменные среды?",
        answers: [
            "ENV",
            "RUN",
            "VOLUME"
        ],
        correct: 1,
        guide: `
            1. FROM - указывает базовый образ, от которого будет производиться сборка<br>
            2. MAINTAINER - указывает информацию о создателе образа<br>
            3. RUN - выполняет команду внутри контейнера во время сборки<br>
            4. CMD - указывает команду, которая будет выполнена при запуске контейнера<br>
            5. EXPOSE - указывает порт, который контейнер будет слушать во время выполнения<br>
            6. ENV - устанавливает переменные среды<br>
            7. ADD/COPY - копирует файлы и директории из хост-системы в контейнер<br>
            8. WORKDIR - устанавливает рабочую директорию для последующих инструкций<br>
            9. VOLUME - создает точку монтирования для постоянного хранения данных<br>
            10. ENTRYPOINT - указывает исполняемый файл или команду, которая будет выполнена при запуске контейнера
        `,
    },
    {
        question: "Чем отличается CMD от ENTRYPOINT в Dockerfile?",
        answers: [
            "ENTRYPOINT выполняет ту же функцию, что и CMD, но может принимать в себя аргументы",
            "ENTRYPOINT выполняет ту же функцию, что и CMD, но может не принимать в себя аргументы",
            "Это абсолютно разные инструкции"
        ],
        correct: 1,
        guide: `
        cmd игнорируется при передаче каких-либо аргументов при запуске контейнера. Допустим, мы хотим настроить добавляемый текст и передать его в качестве аргумента команде docker run. Для этой цели давайте используем entrypoint. Мы укажем команду по умолчанию, которая будет выполняться при запуске контейнера.
        `,
    },
    {
        question: "Чем отличается COPY от ADD в Dockerfile?",
        answers: [
            "Обе инструкции имеют одинаковый функционал",
            "COPY копирует файл / директорию с вашего хоста в ваш образ. ADD копирует файл / каталог с вашего хоста в ваш образ, но также может извлекать удаленные URL-адреса",
            "ADD копирует файл / директорию с вашего хоста в ваш образ. COPY копирует файл / каталог с вашего хоста в ваш образ, но также может извлекать удаленные URL-адреса"
        ],
        correct: 2,
        guide: `
        COPY копирует файл / директорию с вашего хоста в ваш образ.<br>

        ADD копирует файл / каталог с вашего хоста в ваш образ, но также может извлекать удаленные URL-адреса, извлекать файлы TAR и т.д<br>

        COPY используется  для простого копирования файлов и / или каталогов в контекст сборки.<br>

        ADD используется  для загрузки удаленных ресурсов, извлечения файлов TAR и т.д.
        `,
    },
    {
        question: "Какие есть best practices для написания Dockerfile?",
        answers: [
            "Rootless контейнеры, проверенные базовые образы, учетные данные и конфиденциальность",
            "Root контейнеры, проверенные базовые образы, доступность конфиденциальной информации",
            "Редкое обновление образов, сомнительные образы"
        ],
        correct: 1,
        guide: `
        Rootless контейнеры<br>
        Рекомендуем избегать выполнения процесса в контейнере от root. Существует очень небольшой круг задач, для решения которых нужно запускать контейнер от root, поэтому не забывайте добавлять команду USER и менять UID пользователя на non-root<br>
        Внимательно выбирайте базовые образы<br>
        Ваши контейнеры основанные на непроверенных и неподдерживаемых образах унаследуют все проблемы и уязвимости из этих базовых образов<br>
        Учетные данные и конфиденциальность<br>
        Никогда не помещайте чувствительные данные или учетные данные в Dockerfile (через переменные окружения, аргументы или жестко заданными в команде).<br>
        Будьте очень осторожны при копировании файлов внутрь контейнера. Даже если файл удален в последующих командах Dockerfile, к нему все еще можно получить доступ на предыдущих слоях, поскольку на самом деле он не удаляется, а только «скрывается» в окончательной файловой системе.`,
    },
    {
        question: "Какие типы сетевых драйверов используются в docker?",
        answers: [
            "Bride, Host, Overlay, Macvlan, None, Custom",
            "Erase, Host, Rage, Bando",
            "Wap, Jug, Tape, Slime"
        ],
        correct: 1,
        guide: `
        В Docker используются следующие типы сетевых драйверов:<br>
        1. Bridge - используется по умолчанию для создания виртуальной сети, которая позволяет контейнерам общаться друг с другом и с хост-системой.<br>
        2. Host - контейнеры используют сетевые интерфейсы хост-системы, что позволяет им общаться напрямую с внешними устройствами.<br>
        3. Overlay - позволяет создавать сети, которые объединяют контейнеры на разных хостах, что упрощает масштабирование и управление приложениями в распределенной среде.<br>
        4. Macvlan - позволяет назначать контейнерам реальные MAC-адреса и IP-адреса, делая их частью физической сети.<br>
        5. None - отключает сетевой стек у контейнера, что делает его изолированным от сети.<br>
        6. Custom - позволяет создавать собственные сетевые драйверы для специфических потребностей приложений.
        `
    },
    {
        question: "Что такое эфемерные контейнеры?",
        answers: [
            "Эфемерные контейнеры — обычный тип контейнеров, которые используются во многих случаях",
            "Эфемерные контейнеры — это контейнеры, которые используются для долговечного хранения информации",
            "Эфемерные контейнеры — это временные контейнеры, которые создаются и уничтожаются во время выполнения задачи",
        ],
        correct: 3,
        guide: `
        Эфемерные контейнеры — это временные контейнеры, которые создаются и уничтожаются во время выполнения задачи. Их основная особенность состоит в том, что они не сохраняют свое состояние после завершения работы. Такой подход позволяет уменьшить расход ресурсов, улучшить безопасность и ускорить выполнение задач.
        `
    },
    
];



//находим элементы
const headerContainer = document.querySelector('#header');
const listContainer = document.querySelector('#list');
const btn = document.querySelector('#submit');
const popupBtn = document.querySelector('#drop');
const guideText = document.querySelector('#guideText');

//JQUERY
$(".main__box-btn").click(function(){
    $(".main__box-text").toggleClass("main__box-text--active");
});


//игра
let score = 0;
let questionIndex = 0;

//очищаем разметку
clearPage();
showQuestion();
btn.onclick = checkAnswer;
popupBtn.onclick = showGuide;


//ФУНКЦИИ
function showGuide(){
    const guideTemplate = 
    `
    %text%
    `;
    const guide = guideTemplate.replace('%text%', questions[questionIndex]['guide']);
    guideText.innerHTML = guide + "<br> <span>Чтобы перезагрузить подсказку, откройте её ещё раз :)</span>";
}

function clearPage(){
    headerContainer.innerHTML = '';
    listContainer.innerHTML = '';
}

function showQuestion(){
    const headerTemplate = `<h2 class="main__question">%title%</h2>`;
    const title = headerTemplate.replace('%title%', questions[questionIndex]['question']);
    headerContainer.innerHTML = title;

    let answerNumber = 1;
    for (answerText of questions[questionIndex]['answers']){
        const questionTemplate = 
        `
            <li class="main__item">
                            <label class="main__item-label">
                                <input value="%number%" type="radio" name="answer" class="main__item-input">
                                <span class="main__item-check"></span>
                            </label>
                            <span class="main__item-text">%answer%</span>
            </li>
        `;
        
        let answer = questionTemplate.replace('%answer%', answerText);
        answer = answer.replace('%number%', answerNumber);
        listContainer.innerHTML += answer;
        answerNumber++;
    }  
}
function checkAnswer(){
    //находим выбранную кнопку
    const checkedRadio = document.querySelector('input:checked');
    
    //если ответа нет - выход из функции
    if (!checkedRadio){
        btn.blur();
        alert('Вы не выбрали ответ ;(');
        return;
    }

    //находим значение и переводим значение радиокнопки из строки в число
    const userAnswer = parseInt(checkedRadio.value);
    if (userAnswer === questions[questionIndex]['correct']){
        score++;
    }
    if (questions.length-1 !== questionIndex){
        questionIndex++;
        clearPage();
        showQuestion();
    } else{
        clearPage();
        showResults();
        restartQuiz();
    }
}
function showResults(){
    const resultsTemplate = 
    `
        <h2 class="main__title title">%title%</h2>
        <h3 class="main__score">%message%</h3>
        <p class="main__result">%result%</p>
    `;
    let title, message;

    //блок результатов
    if (score === questions.length){
        title = 'Вы молодец йоу 🧛‍♂️';
        message = 'Вы ответили верно на все вопросы! 🌊';

    } else if ((score * 100) / questions.length >= 50){
        title = 'Вот это емае 😲';
        message = 'Вы ответили верно на большую часть вопросов! 🤓';
    } else if ((score * 100) / questions.length < 50){
        title = 'Тилт 😔';
        message = 'Количество вверных ответов меньше половины всех вопросов! 😭';
    }

    let result = `${score} из ${questions.length}`;
    const finalMessage = resultsTemplate
                                    .replace('%title%', title)
                                    .replace('%message%', message)
                                    .replace('%result%', result)
    headerContainer.innerHTML = finalMessage;
}

function restartQuiz(){
    const btnTemplate = 
    `
    %title%
    `;
    const btnHTML = btnTemplate.replace('%title%', 'Обновите страницу :)');
    btn.innerHTML = '';
    btn.innerHTML = btnHTML;
}




