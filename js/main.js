
//МАССИВ
const questions = [
    {
        question: "Что такое LA? В каких единицах измеряется?",
        answers: ["LA (load average) — параметр, определяющий среднюю нагрузку на систему за период времени (1 мин, 5 минут, 15 минут). Измеряется в количестве задач на одно ядро процессора",
        "LA — Los Angeles, город в США. Единицы измерения подразумевают площадь города",
        "LA – употребляется перед существительными женского рода единственного числа (la carrete – катушка, la hija – дочь, la estepa – степь)."
    ],
        correct: 1,
        guide: `Средние значения нагрузки в Linux — это «средние значения нагрузки системы», показывающие потребность в исполняемых потоках (задачах) в виде усреднённого количества исполняемых и ожидающих потоков. Это мера нагрузки, которая может превышать обрабатываемую системой в данный момент. Большинство инструментов показывает три средних значения: для 1, 5 и 15 минут 
        Некоторые интерпретации:

        Если значения равны 0.0, то система в состоянии простоя.
        Если среднее значение для 1 минуты выше, чем для 5 или 15, то нагрузка растёт.
        Если среднее значение для 1 минуты ниже, чем для 5 или 15, то нагрузка снижается.
        Если значения нагрузки выше, чем количество процессоров, то у вас могут быть проблемы с производительностью (в зависимости от ситуации).
        `,
    },
    {
        question: "Что будет если на сервере LA = 100?",
        answers: ["Ничего не изменится",
        "Сервер вовсе перестанет отвечать на запросы пользователя",
        "Вероятно, что на сервере будет наблюдаться замедленная работа сервисов"
    ],
        correct: 3,
        guide:"Если параметр LA равен количеству ядер в системе или количеству потоков в системе, то данная нагрузка является нормальной. Но в остальных случаях может наблюдаться замедленная работа сервисов",
    },
    {
        question: "Почему при высоких показателях значения LA на сервере может не наблюдаться проблем (консоль ssh отзывается, сервисы работают в обычном режиме)?",
        answers: ["На параметр нагрузки LA влияет также и ожидание ввода-вывода (параметр wa в утилите top) в дисков и задержка сети",
        "Сервер оснащён мощным программным обеспечением, которое помогает справиться с высокой нагрузкой",
        "Оба ответа правильные"
    ],
        correct: 1,
        guide:"Ожидание ввода-вывода и задержка сети могут не влиять на работу основных сервисов в системе, но учитываются при расчете общей нагрузки на систему",
    },
    {
        question: `Представлен вывод команды top. Что означает каждая запись в выводе?
        top - 21:29:24 up 14:18, 1 user, load average: 0,78, 1,48, 1,10
        Tasks: 277 total, 3 running, 274 sleeping, 0 stopped, 0 zombie
        %Cpu(s): 12,4 us, 2,5 sy, 0,1 ni, 84,8 id, 0,1 wa, 0,0 hi, 0,1 si, 0,0 st
        KiB Mem : 7106404 total, 306972 free, 3127144 used, 3672288 buff/cache
        KiB Swap: 8191996 total, 8191996 free, 0 used. 3270520 avail Mem`,
        answers: [`top – название утилиты.

        21:29:24 – текущее время системы.
        
        up 14:18 – сколько часов:минут система работает с момента последнего запуска.
        
        1 user – количество пользователей авторизованных в системе.
        
        load average: 0,78, 1,48, 1,10 – параметр средней нагрузки на систему за период времени 1 минута, 5 минут, 15 минут.
        
        277 total – всего процессов в системе.
        `,
    `3 running – количество процессов в работе.

    274 sleeping – количество процессов в состоянии sleeping: ожидает какого-либо события или сигнала.
    
    0 stopped – количество приостановленных процессов сигналом STOP или выполнением трассировки.
    
    0 zombie – количество зомби-процессов, которые завершили своё выполнение, но присутствующие в системе, чтобы дать родительскому процессу считать свой код завершения.
    `,
    `KiB Mem – количество оперативной памяти в кибибайтах (кратно 1024): 7106404 total — всего доступно оперативной памяти в системе, 306972 free — свободно оперативной памяти для использования, 3127144 used — использовано оперативной памяти, 3672288 buff/cache — буферизовано/закешировано оперативной памяти.

    KiB Swap – количество swap-памяти в кибибайтах (кратно 1024), которые выделено на диске: 8191996 total – всего выделено swap-памяти, 8191996 free – свободно swap-памяти 0 used – использовано swap-памяти, 3270520 avail Mem – доступно для использования swap-памяти.
    `,
    "Всё вместе"
    ],
    correct: 4,
    guide:"Top - команда, которая позволяет пользователям отслеживать процессы и использование системных ресурсов в Linux",
    },
    {
        question: "Как в утилите top в Linux посмотреть нагрузку на каждое ядро процессора?",
        answers: ["В утилите top нажать 1, чтобы отобразить все ядра в системе",
        "Прописать команду в терминале: top la",
        "Это невозможно сделать"
    ],
        correct: 1,
        guide:`
        Для работы с утилитой top также используются следующие клавиши: <br>

Пробел — обновить вывод <br>

M — сортировка по используемой памяти <br>

P — сортировка по нагрузке на процессор (используется по умолчанию)<br>

T — сортировка по времени работы процесса<br>

A — сортировка по максимальному потреблению различных ресурсов<br>

u — сортировка по имени пользователя (потребуется ввести имя пользователя)<br>

k — завершить процесс (потребуется указать его идентификатор, PID)<br>

n — изменить количество процессов в выводе (потребуется указать нужное количество)<br>

c — вывести полный путь запущенного процесса (столбец COMMAND)<br>

h — вывод справки<br>

q — выход из программы
        `,
    },
    {
        question: "Как в утилите top в Linux посмотреть какой командой был запущен процесс?",
        answers: ["Прописать команду в терминале: top commands",
        "В утилите top нажать c, чтобы отобразить команды, которыми были запущены процессы",
        "Это невозможно сделать"
    ],
        correct: 2,
        guide:`
        Для работы с утилитой top также используются следующие клавиши: <br>

Пробел — обновить вывод <br>

M — сортировка по используемой памяти <br>

P — сортировка по нагрузке на процессор (используется по умолчанию)<br>

T — сортировка по времени работы процесса<br>

A — сортировка по максимальному потреблению различных ресурсов<br>

u — сортировка по имени пользователя (потребуется ввести имя пользователя)<br>

k — завершить процесс (потребуется указать его идентификатор, PID)<br>

n — изменить количество процессов в выводе (потребуется указать нужное количество)<br>

c — вывести полный путь запущенного процесса (столбец COMMAND)<br>

h — вывод справки<br>

q — выход из программы
        `,
    },
    {
        question: "Где хранятся имена файлов/директорий?",
        answers: ["Команда files, которая хранит и возвращает имена файлов/директорий",
        "В базе данных на отдельном локальном сервере",
        "Имя файла/директории хранится в информационной структуре каталогов"
    ],
        correct: 3,
        guide: `Inodes не содержат имён файлов, только другие метаданные файла.<br>
        Каталоги Unix представляют собой списки ассоциативных структур, каждая из которых содержит одно имя файла и один номер индекса.<br>
        Драйвер файловой системы должен найти каталог, ищущий определенное имя файла, а затем преобразовать имя файла в правильный соответствующий номер индекса.<br>
        <i>Таким образом имя файла/директории хранится в информационной структуре каталов.</i>`,
    },
    {
        question: "Как удалить файл с именем -rf?",
        answers: ["rm -rf",
        "rm ./-rf",
        "rm ./rf"
    ],
        correct: 2,
        guide: `
        Удалить файл, начинающийся с дефиса простым экранированием не получится, и команда rm будет воспринимать дефис, как начало своего аргумента. Решить проблему довольно просто:<br>

        <i>$ rm -f ./-abc</i><br>

        или:<br>

        <i>$ rm -f -- -abc</i>
        `,
    },
    {
        question: "Как посмотреть описание дескриптора? Как посмотреть время последней модификации файла?",
        answers: ["stat 'path_to_file' и stat --format=%y 'path_to_file'",
        "descr 'path_to_file' и descr --format=%y dira",
        "Никак ;("
    ],
        correct: 1,
        guide: `
        Файловый дескриптор — это неотрицательное число, которое является идентификатором потока ввода-вывода. Дескриптор может быть связан с файлом, каталогом, сокетом. <br>
        
        Например, когда вы открываете или создаете новый файл, операционная система формирует для себя запись для представления этого файла и хранения информации о нем. У каждого файла индивидуальный файловый дескриптор Linux. Открыли 100 файлов — где-то в ядре появились 100 записей, представленных целыми числами.<br>
        Команда stat даёт полную информацию о файле и его дескрипторе. Флаг <i>--format=%y</i> позволяет посмотреть время последней модификации файла
        `,
    },
    {
        question: "Для чего нужна переменная окружения PATH?",
        answers: ["Хранит в себе локальные пути к исполняемым файлам",
        "Переменная окружения PATH содержит абсолютные пути директорий, в которых производится поиск исполняемых файлов при вводе команд",
        "Оба варианта верные"
    ],
        correct: 2,
        guide: "Переменная PATH — это системная переменная, которую операционная система использует для того, чтобы найти нужные исполняемые объекты в командной строке или окне терминала",
    },
    {
        question: "Как посмотреть нагрузку на диски?",
        answers: ["Установить утилиту sysstat, проверить нагрузку на диски iostat -xqc",
        "Установить утилиту sysstat, проверить нагрузку на диски iostat -xtc",
        "Установить утилиту suuus, проверить нагрузку на диски impostats -sus"
    ],
        correct: 2,
        guide: "Утилита iostat является частью пакета sysstat. Аргумент -xtc помогает проверить нагрузку на диски",
    },
    {
        question: "Что такое файл в понятиях Unix-like операцинных системах?",
        answers: ["Файлы – это объекты, в которые мы записываем информацию и наши данные, исполняемые файлы, но кроме этих привычных нам понятий здесь есть файлы специального назначения – файлы устройств, файлы туннелей, сокетов и многое другое",
        "Файл – прозрачный перфорированный пакет для документов носит несколько названий «файлик», «мультифора» и «карман».",
        "Файл – именованная область данных на носителе информации, используемая как базовый объект взаимодействия с данными в операционных системах"
    ],
        correct: 1,
        guide: `Unix-like ОС - операционная система, которая образовалась под влиянием Unix. <br>
        Философия операционных систем Unix гласит, что все есть файл. Это значит, что вся работа с этой операционной системой сводится к файлам
        `,
    },
    
    
];



//находим элементы
const headerContainer = document.querySelector('#header');
const listContainer = document.querySelector('#list');
const btn = document.querySelector('#submit');
const popupBtn = document.querySelector('#drop');
const guideText = document.querySelector('#guideText');

//JQUERY
$(".main__box-btn").click(function(){
    $(".main__box-text").toggleClass("main__box-text--active");
});


//игра
let score = 0;
let questionIndex = 0;

//очищаем разметку
clearPage();
showQuestion();
btn.onclick = checkAnswer;
popupBtn.onclick = showGuide;


//ФУНКЦИИ
function showGuide(){
    const guideTemplate = 
    `
    %text%
    `;
    const guide = guideTemplate.replace('%text%', questions[questionIndex]['guide']);
    guideText.innerHTML = guide + "<br> <span>Чтобы перезагрузить подсказку, откройте её ещё раз :)</span>";
}

function clearPage(){
    headerContainer.innerHTML = '';
    listContainer.innerHTML = '';
}

function showQuestion(){
    const headerTemplate = `<h2 class="main__question">%title%</h2>`;
    const title = headerTemplate.replace('%title%', questions[questionIndex]['question']);
    headerContainer.innerHTML = title;

    let answerNumber = 1;
    for (answerText of questions[questionIndex]['answers']){
        const questionTemplate = 
        `
            <li class="main__item">
                            <label class="main__item-label">
                                <input value="%number%" type="radio" name="answer" class="main__item-input">
                                <span class="main__item-check"></span>
                            </label>
                            <span class="main__item-text">%answer%</span>
            </li>
        `;
        
        let answer = questionTemplate.replace('%answer%', answerText);
        answer = answer.replace('%number%', answerNumber);
        listContainer.innerHTML += answer;
        answerNumber++;
    }  
}
function checkAnswer(){
    //находим выбранную кнопку
    const checkedRadio = document.querySelector('input:checked');
    
    //если ответа нет - выход из функции
    if (!checkedRadio){
        btn.blur();
        alert('Вы не выбрали ответ ;(');
        return;
    }

    //находим значение и переводим значение радиокнопки из строки в число
    const userAnswer = parseInt(checkedRadio.value);
    if (userAnswer === questions[questionIndex]['correct']){
        score++;
    }
    if (questions.length-1 !== questionIndex){
        questionIndex++;
        clearPage();
        showQuestion();
    } else{
        clearPage();
        showResults();
        restartQuiz();
    }
}
function showResults(){
    const resultsTemplate = 
    `
        <h2 class="main__title title">%title%</h2>
        <h3 class="main__score">%message%</h3>
        <p class="main__result">%result%</p>
    `;
    let title, message;

    //блок результатов
    if (score === questions.length){
        title = 'Вы молодец йоу 🧛‍♂️';
        message = 'Вы ответили верно на все вопросы! 🌊';

    } else if ((score * 100) / questions.length >= 50){
        title = 'Вот это емае 😲';
        message = 'Вы ответили верно на большую часть вопросов! 🤓';
    } else if ((score * 100) / questions.length < 50){
        title = 'Тилт 😔';
        message = 'Количество вверных ответов меньше половины всех вопросов! 😭';
    }

    let result = `${score} из ${questions.length}`;
    const finalMessage = resultsTemplate
                                    .replace('%title%', title)
                                    .replace('%message%', message)
                                    .replace('%result%', result)
    headerContainer.innerHTML = finalMessage;
}

function restartQuiz(){
    const btnTemplate = 
    `
    %title%
    `;
    const btnHTML = btnTemplate.replace('%title%', 'Обновите страницу :)');
    btn.innerHTML = '';
    btn.innerHTML = btnHTML;
}




